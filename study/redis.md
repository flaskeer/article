SDS简单动态字符串

>set msg "hello world" 
就在数据库中创建一个新的键值对，其中键值对的键是一个保存着字符串的SDS
键值对的值也是一个字符串对象

SDS处了保存数据库中的字符串值，SDS还被用作缓冲区，AOF的AOF缓冲区， 以及客户端状态中的输入缓冲区。

获取SDS的len长度的复杂度是O(1)
不会出现缓冲区溢出的问题。
SDS实现了空间预分配和惰性空间释放两种优化策略

sdshdr
free
len
buf   字节数组 redis用它来保存一系列的二进制数据
SDS:获取字符串长度O(1) API是安全的不会造成缓冲区溢出
     修改字符串长度N次最多需要执行N次内存重分配
     可以保存文本或者二进制数据
     可以使用一部分<string.h>库中的函数
当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就用链表作为列表键的底层实现。

redis链表实现：
双端  无环  带表头指针和表尾指针  带链表长度计数器  多态

链表实现了列表键，发布与订阅，慢查询，监视器等
>set msg "hello world"

要将一个新的键值对添加到字典里面，程序需要先根据键值对的键计算出哈希值和索引值，然后在根据索引值，将包含新建值对的哈希表节点放到哈希表数组的指定索引上面。
hash = dict -> type->hashFunction(key)
index = hash & dict->ht[x].sizemask

当有两个或两个以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些发生了冲突。
redis的哈希表使用链地址法解决键冲突。

随着操作的不断进行，哈希表保存的键值对会逐渐的增多或减少，为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展或收缩。
扩展和收缩哈希表的工作可以执行rehash（重新散列）操作完成。

rehash指的是重新计算键的哈希值和索引值

自动执行rehash
服务器目前没有在执行BGSAVE命令或BGREWRITEAOF命令，并且哈希表的负载因子大于等于1
服务器目前正在执行BGSAVE或者BGREWRIEAOF命令，并且哈希表的负载因子大于等于5
负载因子=哈希表已保存节点数量/哈希表大小
load_factor=ht[0].used/ht[0].size

当哈希表的负载因子小于0.1时，自动对哈希表执行收缩操作。

渐进式rehash中，字典会同时使用ht[0]和ht[1]两个哈希表
删除，查找，更新等会再两个哈希表上进行
新添加的字典的键值对一律会被保存到ht[1]里面，ht[0]则不再进行任何添加操作。
这保证了ht[0]包含的键值对数量只减不增。并随着rehash操作的执行最终变成空表。

每个字典带有两个哈希表，一个平时用，一个仅在进行rehash时使用。

跳跃表通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。

支持平均O(logN)最坏O(N)复杂度的节点查找。还可以通过顺序性批量处理节点，大部分效率可以和平衡树媲美。

如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，redis用跳跃表作为有序集合键的底层实现，

redis使用地方：一个是实现有序集合键，一个是集群节点中用作内部数据结构。

整数集合(inset) 
>SADD numbers 1 3 5
这是redis用于保存整数值的集合抽象数据结构。
可以保存类型int16_t,int32_t.int64_t
当将一个新元素添加到整数集合里，并且新元素的类型比整数集合现有元素类型都要长时，整数集合需要先进行升级。
1根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
2将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。
将新元素添加到底层数组里面。

向整数集合添加新元素的时间复杂度是O(N)

整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。

ziplist压缩列表是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表作为列表键的底层实现，

压缩列表是为了节约内存开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。

连锁更新在最坏情况下需要对压缩列表执行N次控件重分配操作，而每次控件重分配的最坏复杂度为O(N),所以连锁更新的最坏复杂度是O(N^2)

redis使用了基于这些数据结构创建了一个对象系统，这个系统包含字符串对象，列表对象，哈希对象，集合对象和有序集合对象这五种类型对象。

还实现了基于引用计数的额内存回收计数。当程序不再使用某个对象的时候，这个对象所占用的内存就会被释放，另外redis还通过引用计数实现了对象更想机制。这个机制可以再适当情况下通过让多个数据库键共享同一个对象来节约内存。

每当我们在redis创建一个键值对，我们至少创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值。

键总是一个字符串对象，值可以是任意一种，
REDIS_STRING REDIS_LIST REDIS_HASH REDIS_SET REDIS_ZSET有序集合对象

TYPE返回为数据库键对应的值对象的类型。不是键对象的类型，

Object ENCODING numbers


如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个SDS来保存这个字符串值，并将对象编码设置为raw

字符串值长度小于等于32字节，使用embstr编码方式保存。
释放embstr编码的字符串对象只需要调用一次内存释放函数
raw编码的字符串对象需要调用两次内存释放函数

SET GET APPEND INCRBYFLOAT INCRBY DECRBY STRLEN SETRANGE
GETRANGE

字符串对象时redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。

LPUSH RPUSH LPOP RPOP LLEN LINSERT LREM LTRIM  LSET

哈希键HSET HGET HEXISTS HDEL HGETALL 

集合键SADD SCARD SISMEMBER SMEMBERS SRANDMEMBER SPOP SREM


有序键ZADD ZCARD ZCOUNT ZREVRANGE ZRANK ZREVRANK ZREM ZSCORE 

对象的引用计数信息会随着对象的使用状态而不断变化
对象生命周期分为创建，操作，释放三个阶段。

共享机制对于节约内存非常有帮助。

OBJECT IDLETIME msg 键处于活跃状态，空转时长为0  （integer）0

SELECT 2 切换数据库
默认创建16个数据库

修改redisClient.db指针，让他指向服务器中的不同服务器。从而实现切换目标数据库的功能。

添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，值则为任意一种类型的redis对象。

删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。

对一个数据库键进行更新，实际上就是对键空间里面键对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。

对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象。根据值对象的类型不同，具体的取值方法也会有所不同。

清空整个数据库的FLUSHDB，就是通过删除键空间中的所有键值对实现的。用于随机返回数据库中某个键的RANDOMKEY，就是通过在键空间中随机返回一个键实现的。

返回数据库键数量的DBSIZE，就是通过返回键空间中包含的键值对的数量来实现的。

读取键之后，服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数。

读取键之后，服务器会更新LRU(最后一次使用时间)，可以用来计算键的闲置时间。

服务器读取键时发现该键已经过期，那么服务器会先删除这个过期键，然后执行余下操作。

EXPIRE 可以以秒或者毫秒精度为数据库中的某个键设置生存时间(TTL)

过期时间是一个UNIX时间戳。

EXPIREAT将key的过期时间设置为timestamp所指定的秒数时间

PEXPIREAT 可以移除一个键的过期时间

TTL以秒为单位返回键的剩余生存时间  返回值大于0证明该键未过期

PTTL以毫秒为单位返回键的剩余生存时间

定时删除：创建一个定时器   主动
惰性删除：放任键过期不管   主动
定期删除：每隔一段时间，程序对数据库进行一次检查  被动

定时删除占用太多CPU时间，影响服务器的响应时间和吞吐量
惰性删除浪费太多内存，有内存泄露的风险。

定期删除是前两种的折中和整合

执行SAVE或者BGSAVE创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中

AOF运行时，数据库的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键产生任何影响。
当过期键被惰性删除或者定期删除之后，程序会向AOF追加一条DEL命令显示记录该键已被删除。

关注某个键执行了什么命令的通知称为键空间通知。键事件通知的通知，关注的是某个命令被什么键执行了。

Redis是一种持久化的存储器内存储（in-memory persistent store）。对于持久化，默认情
况下，Redis会根据已变更的关键字数量来进行判断，然后在磁盘里创建数据库的快照（snapshot）。你可以对
此进行设置，如果X个关键字已变更，那么每隔Y秒存储数据库一次。默认情况下，如果1000个或更多的关键字
已变更，Redis会每隔60秒存储数据库；而如果9个或更少的关键字已变更，Redis会每隔15分钟存储数据库。

关键字（Keys）是用于标识一段数据的一个字符串
• 值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么
• Redis展示了（也实现了）5种专门的数据结构
• 上面的几点使得Redis快速而且容易使用，但要知道Redis并不适用于所有的应用场景

如果服务器开启了AOF持久化功能，那么服务器优先使用AOF文件还原数据库状态
只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。

FLUSHALL 创建一个数据库状态为空的RDB文件
SAVE
od -c dump.rdb 

RDB持久化是通过保存数据库中的键值对来记录数据库的状态不同,AOF持久化是通过保存redis服务器所执行的写命令来记录数据库状态的。

AOF持久化分为命令追加，文件写入，文件同步三个步骤

redis服务器进程就是一个事件循环，这个循环的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行像serverCron这样需要定时运行的函数。

为了解决AOF文件体积膨胀的问题，redis提供了AOF文件重写，可以创建一个新的AOF文件替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF不会包含任何浪费空间的冗余命令，所以新AOF文件的体积比旧AOF文件体积小的多。

redis基于reactor模式开发了自己的网络事件处理器，这称为文件事件处理器。
文件事件处理器使用了IO多路复用程序同时监听多个套接字。
当被监听的套接字准备好知性连接应答，读取，写入，关闭。与操作相对应的文件事件就会产生。

组成部分：套接字，IO多路复用，文件事件分派器，事件处理器

redis时间事件分为两类：定时事件  周期性事件
时间事件的属性：id  when  timeProc

持续运行的redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期稳定的运行。

redis服务器使用单线程但进程的方式来处理命令请求，并与多个客户端进行网络通信。

固定大小的缓冲区用于保存那些长度比较小的回复。
可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。

输出缓冲区限制值有两种。如果输入缓冲区的大小超过了服务器设置的硬性限制，吗么客户端会被立刻关闭，如果客户端在一定时间内， 那么客户端也会被关闭。

redis服务器不少功能需要获取系统的当前时间，每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态的unixtime属性和mstime属性被用作当前时间的缓存。

服务器在关闭自身之前会进行RDB持久化操作，这也是服务器拦截SIGTERM信号的原因，如果服务器一接到SIGTERM信号就立即关闭就没办法持久化操作了。

serverCron函数默认每隔100毫秒执行一次，工作包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。

SLAVEOF命令让一个服务器去复制另一个服务器，被复制的是主服务器，进行复制的是从服务器。

复制分为同步和命令传播。

redis的发布与订阅由PUBLISH SUBCRIBE PSUBSCRIBE组成
SUBCRIBE，客户可以订阅一个或多个频道，从而成为这些频道的订阅者。每当其他客户端向被订阅的频道发送消息，频道的所有订阅者都会收到这条消息。

SUBCRIBE  UNSUBSCRIBE退订频道
PSUBSCRIBE PUNSUBSCRIBE 退订模式

PUBSUB CHANNELS [pattern] 用于返回服务器当前被订阅的频道

PUBSUB NUMSUB [channel1 channel2] 接受任意多个频道作为输入参数，并返回这些频道的订阅者数量

PUBSUB NUMPAT 用于返回服务器当前被订阅模式的数量

redis通过MULTI,EXEC,WATCH命令实现事务，提供了一种将多个命令请求打包，然后一次性按顺序的执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而该去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

MULTI   事务开始
...     非事务状态时，这个客户端发送的命令会立即被服务器执行

EXEC     如果是EXEC,DISCARD, WATCH,MULTI四个命令其中一个，那么服务器立即去执行这个命令
除此之外将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。

客户端向服务器发送EXEC时，立即被服务器执行，服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得结果返回给客户端。

WATCH是一个乐观锁，可以再EXEC之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复.

WATCH "name"
MULTI
SET "name" "peter"
EXEC

redis的事务来说，事务队列中的命令要么就全部执行，要么就一个都不执行，redis的事务是具有原子性的

redis事务不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。

如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确，那么redis拒绝执行这个事务。
即使事务执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响

无论redis服务器运行在何种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。

redis使用单线程的方式执行事务，并且服务器保证早执行事务期间不会对事务进行中断，因此redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。




















